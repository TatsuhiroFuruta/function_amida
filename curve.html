<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>曲線通路のあみだくじサンプル</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;margin:20px;background:#fafafa;color:#111}
    .controls{display:flex;gap:8px;align-items:center;margin-bottom:12px}
    label{font-size:14px}
    input[type=number]{width:72px;padding:6px;border-radius:6px;border:1px solid #ddd}
    button{padding:8px 12px;border-radius:8px;border:0;background:#2563eb;color:#fff;cursor:pointer}
    button:active{transform:translateY(1px)}
    .canvas-wrap{background:#fff;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
    svg{width:100%;height:500px;display:block}
    .lane-label{font-size:12px;user-select:none}
    .result-list{margin-top:12px}
    .result-item{padding:6px;border-radius:6px;background:#f3f4f6;margin-bottom:6px}
    small.hint{color:#666}
  </style>
</head>
<body>
  <h1>曲線通路のあみだくじ（デモ）</h1>
  <div class="controls">
    <label>人数（縦線）: <input id="lanes" type="number" min="2" max="12" value="5"></label>
    <label>橋（通路）数: <input id="bridges" type="number" min="0" max="30" value="6"></label>
    <button id="generate">生成</button>
    <button id="traceAll">全員トレース</button>
    <div style="margin-left:12px"><small class="hint">※ 通路は隣接するレーン間のみ。交差を避けます。</small></div>
  </div>

  <div class="canvas-wrap">
    <svg id="svg" viewBox="0 0 800 500" preserveAspectRatio="xMidYMid meet"></svg>
  </div>

  <div class="result-list" id="results"></div>

  <script>
    // ---- 設定 ----
    const svg = document.getElementById('svg');
    const W = 800, H = 500; // viewBox size
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

    // レンダリングパラメータ
    const topMargin = 60;
    const bottomMargin = 120;

    function generateRandomAmida(lanesCount, bridgesCount) {
      // lanes: x座標, labels
      const laneSpacing = (W - 120) / (lanesCount - 1);
      const lanes = new Array(lanesCount).fill(0).map((_, i) => ({
        idx: i,
        x: 60 + i * laneSpacing
      }));

      // generate bridges between adjacent lanes with random y, avoid overlaps (no two bridges share same y or adjacent at similar y)
      const bridges = [];
      const minY = topMargin + 10;
      const maxY = H - bottomMargin - 10;
      const triesLimit = 1000;

      let tries = 0;
      while (bridges.length < bridgesCount && tries < triesLimit) {
        tries++;
        const from = Math.floor(Math.random() * (lanesCount - 1)); // connect from -> from+1
        const y = Math.random() * (maxY - minY) + minY;

        // check conflicts: too close in y to existing bridge on same pair or adjacent pair
        const conflict = bridges.some(b => {
          if (Math.abs(b.y - y) < 24) return true; // vertical spacing to avoid overlap
          if (Math.abs(b.from - from) <= 1 && Math.abs(b.y - y) < 36) return true; // adjacent crossing too close
          return false;
        });
        if (conflict) continue;

        bridges.push({from, to: from + 1, y});
      }

      // sort by y ascending (top -> bottom)
      bridges.sort((a,b)=>a.y - b.y);
      return {lanes, bridges};
    }

    function clearSVG() { while (svg.firstChild) svg.removeChild(svg.firstChild); }

    function renderAmida(lanes, bridges, names) {
      clearSVG();

      // background
      const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
      bg.setAttribute('x',0);bg.setAttribute('y',0);bg.setAttribute('width',W);bg.setAttribute('height',H);bg.setAttribute('fill','none');
      svg.appendChild(bg);

      // vertical lanes
      lanes.forEach((lane,i)=>{
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',lane.x);line.setAttribute('y1',topMargin);line.setAttribute('x2',lane.x);line.setAttribute('y2',H-bottomMargin);
        line.setAttribute('stroke','#222');line.setAttribute('stroke-width',2);
        svg.appendChild(line);

        // top label
        const topText = document.createElementNS('http://www.w3.org/2000/svg','text');
        topText.setAttribute('x',lane.x);topText.setAttribute('y',topMargin-22);topText.setAttribute('text-anchor','middle');
        topText.setAttribute('class','lane-label');topText.textContent = names && names[i] ? names[i] : `P${i+1}`;
        svg.appendChild(topText);

        // bottom result placeholder
        const bottomText = document.createElementNS('http://www.w3.org/2000/svg','text');
        bottomText.setAttribute('x',lane.x);bottomText.setAttribute('y',H-bottomMargin+36);bottomText.setAttribute('text-anchor','middle');
        bottomText.setAttribute('class','lane-label');bottomText.textContent = `?`;
        bottomText.setAttribute('id',`result-${i}`);
        svg.appendChild(bottomText);
      });

      // curved bridges (通路)
      bridges.forEach((b, idx)=>{
        const a = lanes[b.from];
        const c = lanes[b.to];
        // quadratic curve control point slightly bumped to create a smooth curve
        const mx = (a.x + c.x)/2;
        const ctrlY = b.y - 20 * ( (Math.random()*2-1) ); // randomness in bend direction
        const path = document.createElementNS('http://www.w3.org/2000/svg','path');
        const d = `M ${a.x} ${b.y} Q ${mx} ${ctrlY} ${c.x} ${b.y}`;
        path.setAttribute('d',d);
        path.setAttribute('fill','none');
        path.setAttribute('stroke','#6b7280');
        path.setAttribute('stroke-width',6);
        path.setAttribute('stroke-linecap','round');
        path.setAttribute('data-from',b.from);
        path.setAttribute('data-to',b.to);
        path.setAttribute('data-y',b.y);
        path.setAttribute('id',`bridge-${idx}`);
        svg.appendChild(path);

        // small circle markers at connection points to emphasize where lane changes happen
        [a.x, c.x].forEach((xpos)=>{
          const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circ.setAttribute('cx',xpos);circ.setAttribute('cy',b.y);circ.setAttribute('r',6);
          circ.setAttribute('fill','#111');circ.setAttribute('opacity',0.08);
          svg.appendChild(circ);
        });
      });

      // clickable top labels to trace single path
      lanes.forEach((lane,i)=>{
        const btn = document.createElementNS('http://www.w3.org/2000/svg','rect');
        btn.setAttribute('x',lane.x-28);btn.setAttribute('y',topMargin-40);btn.setAttribute('width',56);btn.setAttribute('height',28);
        btn.setAttribute('fill','transparent');btn.setAttribute('cursor','pointer');
        btn.addEventListener('click',()=>traceSingle(i, lanes, bridges));
        svg.appendChild(btn);
      });

      // initial bottom results: compute mapping
      const mapping = computeResults(lanes, bridges);
      mapping.forEach((toIdx, fromIdx)=>{
        const el = document.getElementById(`result-${toIdx}`);
        if (el) el.textContent = names && names[fromIdx] ? names[fromIdx] : `P${fromIdx+1}`;
      });

      // show results list below
      showResultsList(mapping, names);
    }

    function computeResults(lanes, bridges) {
      // simulate each start lane going down, applying swaps in order by y
      const n = lanes.length;
      const mapping = new Array(n).fill(0).map((_,i)=>i);

      // for each bridge from top to bottom
      bridges.forEach(b=>{
        // swap positions mapping for indices b.from and b.to
        const f = b.from;
        const t = b.to;
        // find which start indexes are currently at columns f and t
        // mapping is array where mapping[startIdx] = currentColumn
        // We need inverse: column -> startIdx
        const colToStart = new Array(n);
        mapping.forEach((col,start)=>{ colToStart[col]=start; });
        const startAtF = colToStart[f];
        const startAtT = colToStart[t];
        // swap their columns
        mapping[startAtF] = t;
        mapping[startAtT] = f;
      });

      // mapping[start] = final column index
      // we want result array finalColumn -> start
      const finalToStart = new Array(n);
      mapping.forEach((finalCol,start)=>{ finalToStart[finalCol]=start; });
      return finalToStart;
    }

    function showResultsList(mapping, names){
      const container = document.getElementById('results');
      container.innerHTML = '<h3>結果（下の枠に表示）</h3>';
      mapping.forEach((startIdx, finalIdx)=>{
        const div = document.createElement('div');
        div.className = 'result-item';
        div.textContent = `下 ${finalIdx+1} ← ${names && names[startIdx] ? names[startIdx] : `P${startIdx+1}`}`;
        container.appendChild(div);
      });
    }

    // simple animation to trace a single player's path
    function traceSingle(startIdx, lanes, bridges) {
      // build path segments: vertical from top to first bridge y, then curve, etc.
      const startX = lanes[startIdx].x;
      let currentCol = startIdx;
      const segments = [];
      let lastY = topMargin;

      // iterate bridges in order
      bridges.forEach(b=>{
        if (b.from === currentCol || b.to === currentCol) {
          // vertical down to b.y
          segments.push({type:'v', x:lanes[currentCol].x, y1:lastY, y2:b.y});
          // then horizontal curve to adjacent column
          const otherCol = (b.from === currentCol) ? b.to : b.from;
          segments.push({type:'c', from:lanes[currentCol], to:lanes[otherCol], y:b.y});
          currentCol = otherCol;
          lastY = b.y;
        }
      });
      // final vertical to bottom
      segments.push({type:'v', x:lanes[currentCol].x, y1:lastY, y2:H-bottomMargin});

      // draw animation path as polyline approximating
      const pathPoints = [];
      segments.forEach(seg=>{
        if (seg.type==='v'){
          pathPoints.push([seg.x, seg.y1]);
          pathPoints.push([seg.x, seg.y2]);
        } else if (seg.type==='c'){
          // approximate quadratic curve with a few points
          const ax=seg.from.x, bx=seg.to.x, y=seg.y;
          const mx=(ax+bx)/2; const ctrlY = y - 20;
          // sample t=0..1
          for (let t=0;t<=1;t+=0.25){
            const xt = (1-t)*(1-t)*ax + 2*(1-t)*t*mx + t*t*bx;
            const yt = (1-t)*(1-t)*y + 2*(1-t)*t*ctrlY + t*t*y;
            pathPoints.push([xt,yt]);
          }
        }
      });

      // remove any existing animation
      const old = document.getElementById('trace-path'); if (old) old.remove();
      const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      poly.setAttribute('id','trace-path');
      poly.setAttribute('points', pathPoints.map(p=>p.join(',')).join(' '));
      poly.setAttribute('fill','none');
      poly.setAttribute('stroke','#ef4444');
      poly.setAttribute('stroke-width',4);
      poly.setAttribute('stroke-linecap','round');
      poly.setAttribute('stroke-linejoin','round');
      poly.setAttribute('opacity',0.95);
      svg.appendChild(poly);

      // simple CSS dash animation
      poly.style.transition = 'stroke-dashoffset 1.6s linear';
      const length = poly.getTotalLength ? poly.getTotalLength() : 1000;
      poly.setAttribute('stroke-dasharray', length);
      poly.setAttribute('stroke-dashoffset', length);
      // trigger
      requestAnimationFrame(()=>{ poly.setAttribute('stroke-dashoffset', '0'); });
    }

    // UI wiring
    document.getElementById('generate').addEventListener('click', ()=>{
      const lanesNum = Math.max(2, Math.min(12, parseInt(document.getElementById('lanes').value || 5)));
      const bridgesNum = Math.max(0, Math.min(100, parseInt(document.getElementById('bridges').value || 6)));
      const names = new Array(lanesNum).fill(0).map((_,i)=>`P${i+1}`);
      const {lanes, bridges} = generateRandomAmida(lanesNum, bridgesNum);
      renderAmida(lanes, bridges, names);
    });

    document.getElementById('traceAll').addEventListener('click', ()=>{
      const lanesNum = Math.max(2, Math.min(12, parseInt(document.getElementById('lanes').value || 5)));
      const bridgesNum = Math.max(0, Math.min(100, parseInt(document.getElementById('bridges').value || 6)));
      const names = new Array(lanesNum).fill(0).map((_,i)=>`P${i+1}`);
      const {lanes, bridges} = generateRandomAmida(lanesNum, bridgesNum);
      renderAmida(lanes, bridges, names);
      // animate each one in sequence
      const mapping = computeResults(lanes, bridges);
      let i=0;
      const timer = setInterval(()=>{
        if (i>=lanesNum) { clearInterval(timer); return; }
        traceSingle(i, lanes, bridges);
        i++;
      }, 900);
    });

    // initial render
    document.getElementById('generate').click();
  </script>
</body>
</html>
